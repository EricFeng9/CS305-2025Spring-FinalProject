# 区块链网络仿真项目开发手册

## 目录
1. [项目概述](#项目概述)
2. [分工方案](#分工方案)
   - [同学A：网络基础与节点管理](#同学a网络基础与节点管理)
   - [同学B：交易与区块核心逻辑](#同学b交易与区块核心逻辑)
   - [同学C：消息处理高级功能与监控面板](#同学c消息处理高级功能与监控面板)
3. [接口约定](#接口约定)
   - [消息格式约定](#消息格式约定)
   - [模块间接口调用约定](#模块间接口调用约定)
4. [开发标准](#开发标准)
   - [代码风格](#代码风格)
   - [异常处理](#异常处理)
   - [日志记录](#日志记录)
   - [版本控制](#版本控制)
5. [测试标准](#测试标准)
   - [单元测试标准](#单元测试标准)
   - [集成测试标准](#集成测试标准)
   - [系统测试标准](#系统测试标准)

## 项目概述

本项目旨在模拟区块链系统中的P2P网络通信，重点实现以下功能：
- 节点初始化与发现
- 消息发送与接收处理
- 交易与区块的生成与验证
- 仪表盘监控

项目基于Docker技术部署，每个节点在独立容器中运行。项目要求实现各类消息的处理逻辑，包括节点发现、交易和区块广播、NAT穿透等特性。

## 分工方案

### 同学A：网络基础与节点管理

#### 核心职责
负责节点程序的基础网络通信能力的建立，以及节点间的发现和状态维护。

#### 主要负责模块和功能点
1. **Peer Initialization (socket_server.py)**
   - `start_socket_server`: 创建TCP套接字，监听端口，接收消息。

2. **Peer Discovery (peer_discovery.py)**
   - `start_peer_discovery`: 定义并发送HELLO消息。
   - `handle_hello_message`: 处理收到的HELLO消息，更新已知节点列表。

3. **Peer Management (peer_manager.py)**
   - `start_ping_loop`: 周期性发送PING消息。
   - `create_pong`: 创建PONG消息。
   - `handle_pong`: 处理PONG消息，更新RTT。
   - `start_peer_monitor`: 监控节点状态。
   - `update_peer_heartbeat`: 更新节点心跳时间。
   - `record_offense`: 记录违规行为。

#### 独立测试要点
- 节点能够成功启动并监听端口
- 节点能发现并维护已知节点列表
- 正确计算节点间RTT
- 正确标记节点状态(ALIVE/UNREACHABLE)
- 违规行为记录和黑名单功能正常工作

### 同学B：交易与区块核心逻辑

#### 核心职责
负责区块链核心功能的实现，包括交易和区块的生成、验证、存储和同步逻辑。

#### 主要负责模块和功能点
1. **Transaction (transaction.py)**
   - `transaction_generation`: 生成新交易并广播。
   - `add_transaction`: 将交易添加到本地交易池。
   - `get_recent_transaction`: 获取交易池中的交易。
   - `clear_pool`: 清空交易池。

2. **Block Handling (block_handler.py)**
   - `request_block_sync`: 请求同步区块头。
   - `block_generation`: 周期性生成新区块。
   - `create_dummy_block`: 创建区块结构。
   - `compute_block_hash`: 计算区块哈希。
   - `handle_block`: 处理接收到的区块。
   - `create_getblock`: 创建GETBLOCK消息。
   - `get_block_by_id`: 根据ID获取区块。

3. **Inventory Message (inv_message.py)**
   - `create_inv`: 创建INV消息。
   - `get_inventory`: 获取本地区块链的所有区块ID。
   - `broadcast_inventory`: 广播本地库存信息。

#### 独立测试要点
- 交易能正确生成、验证并加入交易池
- 区块能从交易池正确打包，哈希计算正确
- 收到INV后正确识别缺失区块并请求
- 收到区块后正确验证、存储
- 孤块处理逻辑正确
- 轻量级节点与全节点的差异化处理正确

### 同学C：消息处理高级功能与监控面板

#### 核心职责
负责消息收发的健壮性和高级特性实现，以及系统状态可视化。

#### 主要负责模块和功能点
1. **Sending Message Processing (outbox.py)**
   - `enqueue_message`: 消息入队，包括优先级和速率控制。
   - `send_from_queue`: 按优先级从队列取消息发送。
   - `relay_or_direct_send`: 处理NAT穿透逻辑。
   - `get_relay_peer`: 选择最佳中继节点。
   - `send_message`: 实际发送消息。
   - `apply_network_conditions`: 模拟网络条件。
   - `start_dynamic_capacity_adjustment`: 动态调整发送能力。
   - `gossip_message`: 实现Gossip协议扇出逻辑。

2. **Receiving Message Processing (message_handler.py)**
   - `dispatch_message`: 消息分发入口，通用检查和特定类型处理。
   - `is_inbound_limited`: 入站消息频率限制。
   - `get_redundancy_stats`: 冗余消息统计。

3. **Dashboard (dashboard.py)**
   - 实现所有展示系统状态的API端点。

#### 独立测试要点
- 消息队列的优先级和出队逻辑正确
- 速率限制功能正常工作
- NAT穿透和RELAY消息处理正确
- 网络模拟(丢包、延迟)正常
- Dashboard各接口数据展示正确
- 安全机制(如DoS防护)有效

## 接口约定

### 消息格式约定

所有消息采用JSON格式，必须包含以下基本字段：
- `msg_type`: 消息类型，如"HELLO", "PING", "BLOCK"等
- `sender_id`: 发送者标识(通常为peer_port)
- `message_id`: 唯一消息标识(可通过util.py中的generate_message_id生成)

各类型消息的特定字段如下：

1. **HELLO消息**
   ```json
   {
     "msg_type": "HELLO",
     "sender_id": "<peer_port>",
     "ip": "<ip_address>",
     "port": "<port>",
     "flags": {"is_nated": <true/false>, "is_full": <true/false>},
     "message_id": "<random_id>"
   }
   ```

2. **PING消息**
   ```json
   {
     "msg_type": "PING",
     "sender_id": "<peer_port>",
     "timestamp": "<current_time>",
     "message_id": "<random_id>"
   }
   ```

3. **PONG消息**
   ```json
   {
     "msg_type": "PONG",
     "sender_id": "<peer_port>",
     "timestamp": "<ping_timestamp>",
     "message_id": "<random_id>"
   }
   ```

4. **TX消息**
   ```json
   {
     "msg_type": "TX",
     "sender_id": "<peer_port>",
     "tx_id": "<transaction_hash>",
     "from": "<sender_address>",
     "to": "<receiver_address>",
     "amount": "<amount>",
     "message_id": "<random_id>"
   }
   ```

5. **BLOCK消息**
   ```json
   {
     "msg_type": "BLOCK",
     "sender_id": "<peer_port>",
     "timestamp": "<current_time>",
     "block_id": "<block_hash>",
     "prev_block_id": "<previous_block_hash>",
     "transactions": [<tx1>, <tx2>, ...],
     "message_id": "<random_id>"
   }
   ```

6. **INV消息**
   ```json
   {
     "msg_type": "INV",
     "sender_id": "<peer_port>",
     "block_ids": ["<block_id1>", "<block_id2>", ...],
     "message_id": "<random_id>"
   }
   ```

7. **GETBLOCK消息**
   ```json
   {
     "msg_type": "GETBLOCK",
     "sender_id": "<peer_port>",
     "block_ids": ["<block_id1>", "<block_id2>", ...],
     "message_id": "<random_id>"
   }
   ```

8. **RELAY消息**
   ```json
   {
     "msg_type": "RELAY",
     "sender_id": "<peer_port>",
     "target_id": "<target_peer_id>",
     "payload": <original_message>,
     "message_id": "<random_id>"
   }
   ```

9. **GET_BLOCK_HEADERS消息**
   ```json
   {
     "msg_type": "GET_BLOCK_HEADERS",
     "sender_id": "<peer_port>",
     "message_id": "<random_id>"
   }
   ```

10. **BLOCK_HEADERS消息**
    ```json
    {
      "msg_type": "BLOCK_HEADERS",
      "sender_id": "<peer_port>",
      "headers": [<block_header1>, <block_header2>, ...],
      "message_id": "<random_id>"
    }
    ```

### 模块间接口调用约定

1. **消息发送约定**
   - 所有模块发送消息必须通过`outbox.py`的`enqueue_message`或`gossip_message`函数
   - 发送函数签名：`enqueue_message(sender_id, receiver_id, message)`
   - Gossip函数签名：`gossip_message(sender_id, message, skip_lightweight=False)`

2. **消息接收约定**
   - 所有接收到的消息由`message_handler.py`的`dispatch_message`函数分发处理
   - 根据消息类型，调用相应模块的处理函数

3. **节点管理约定**
   - 记录违规行为通过调用`peer_manager.py`的`record_offense(peer_id, offence_type)`
   - 判断节点是否在黑名单：`peer_id in peer_manager.blacklist`

4. **数据结构访问约定**
   - 已知节点列表：`peer_discovery.known_peers`
   - 节点状态：`peer_manager.peer_status`
   - 节点标志(flags)：`peer_discovery.peer_flags`
   - 可达性信息：`peer_discovery.reachable_by`
   - 传输延迟：`peer_manager.rtt_tracker`
   - 本地区块链：`block_handler.blockchain`
   - 孤块列表：`block_handler.orphan_blocks`
   - 交易池：`transaction.tx_pool`

## 开发标准

### 代码风格

1. **命名规范**
   - 变量/函数名：使用小写字母和下划线(snake_case)
   - 常量：使用大写字母和下划线
   - 类名：使用首字母大写(CamelCase)

2. **注释规范**
   - 每个函数必须有文档字符串，说明功能、参数和返回值
   - 复杂逻辑需要行内注释
   - 使用英文注释

3. **代码格式**
   - 使用4空格缩进，不使用制表符
   - 行长度限制在79字符以内
   - 遵循PEP 8规范

### 异常处理

1. 使用try-except捕获可预见的异常，避免程序崩溃
2. 对于网络通信错误，必须实现重试机制
3. 记录异常信息到日志，但不要泄露敏感信息
4. 避免捕获过于宽泛的异常(如`except Exception:`)

### 日志记录

1. 使用Python标准logging模块记录日志
2. 定义统一的日志格式：`[时间][模块][级别] 消息`
3. 日志级别使用:
   - ERROR: 错误和异常情况
   - WARNING: 警告和潜在问题
   - INFO: 重要流程信息
   - DEBUG: 调试信息

### 版本控制

1. 使用Git进行版本控制
2. 提交规范: `[模块] 简短描述`
3. 每个功能点创建独立分支，完成后合并到主分支
4. 不要提交编译生成的文件、临时文件和配置文件
5. 每天至少提交一次代码

## 测试标准

### 单元测试标准

1. **测试覆盖度**
   - 每个函数必须至少有一个测试用例
   - 关键函数需测试正常情况和边界情况
   - 目标覆盖率：行覆盖率>80%

2. **测试框架**
   - 使用Python标准unittest或pytest框架
   - 测试文件命名：`test_<module_name>.py`
   - 测试函数命名：`test_<function_name>_<scenario>`

3. **同学A测试重点**
   - `socket_server.py`:
     - 测试服务器能否正确启动和接收消息
     - 使用mock socket测试
   - `peer_discovery.py`:
     - 测试HELLO消息格式是否正确
     - 测试已知节点列表更新逻辑
   - `peer_manager.py`:
     - 测试PING/PONG逻辑和RTT计算
     - 测试节点状态监控
     - 测试违规记录和黑名单功能

4. **同学B测试重点**
   - `transaction.py`:
     - 测试交易生成和验证
     - 测试交易池管理
   - `block_handler.py`:
     - 测试区块生成、哈希计算
     - 测试区块验证和处理
     - 测试孤块处理
     - 测试轻量级节点功能
   - `inv_message.py`:
     - 测试INV消息创建
     - 测试区块同步逻辑

5. **同学C测试重点**
   - `outbox.py`:
     - 测试消息队列和优先级
     - 测试速率限制
     - 测试NAT穿透逻辑
     - 测试网络模拟
   - `message_handler.py`:
     - 测试消息分发
     - 测试重放攻击防护
     - 测试入站限速
   - `dashboard.py`:
     - 测试各API端点返回格式

### 集成测试标准

1. **模块间协作测试**
   - 测试节点发现 + 消息发送
   - 测试交易生成 + 消息广播 + 交易验证
   - 测试区块生成 + 消息广播 + 区块验证

2. **测试环境**
   - 在Docker容器中测试
   - 创建小型网络(3-5个节点)进行测试

3. **场景测试**
   - 新节点加入网络
   - 节点离开网络
   - 交易广播和验证
   - 区块广播和验证
   - NAT穿透测试
   - 节点状态变化测试

### 系统测试标准

1. **全系统测试**
   - 使用docker-compose启动完整的10节点网络
   - 测试系统运行一段时间(至少1小时)的稳定性
   - 监控系统资源使用(CPU、内存、网络)

2. **异常测试**
   - 模拟节点突然宕机
   - 模拟网络分区
   - 模拟恶意节点(发送非法交易/区块)
   - 模拟DoS攻击

3. **性能测试**
   - 测量交易吞吐量(TPS)
   - 测量区块传播延迟
   - 测量消息冗余度
   - 测量不同gossip fanout值对系统性能的影响

4. **Dashboard功能测试**
   - 验证所有API端点返回正确数据
   - 测试数据刷新机制

通过以上开发和测试标准，我们可以确保项目模块的独立开发、有效对接和全面测试，提高项目质量并降低集成风险。 