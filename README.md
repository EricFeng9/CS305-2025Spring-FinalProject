# CS305 2025 Spring Final Project - Blockchain Network Simulation

## 1. Introduction

Bitcoin and Ethereum are the most well-known and popular cryptocurrency systems with high security and privacy preservation. In these systems, users can freely exchange digital coins (e.g., BTC and ETH) without exposing their identities and relying on any centralized entities, e.g., banks or Alipay. These advantages originate in their underlying technology -- **Blockchain**.  

A blockchain is a decentralized ledger that stores an ever-expanding sequence of records, known as blocks, which are securely connected through cryptographic hashes. Each block includes the hash of the previous block, a timestamp, and a set of transaction data—often organized in a Merkle tree structure with the transactions at the leaves. This design forms a chain-like structure, where each block is linked to its predecessor, similar to a linked list. Because each block depends on the integrity of the one before it, altering data retroactively would require modifying all subsequent blocks and achieving consensus across the network. This makes blockchain systems highly resistant to tampering and helps prevent issues like double-spending, counterfeiting, fraud, and unauthorized creation of assets.

Regarding a blockchain system, Ethereum is taken as an example here. Ethereum is a public blockchain system which all entities can freely join or leave. Entities in the system are called blockchain peers (*simply* **peers**), which can not only generate transactions but also verify transactions generated by other peers and package valid transactions in the form of blocks. These blocks are then verified by all peers in the system and linked to the blockchain if most peers accept them. This process is called blockchain consensus (i.e., block generation and verification). Here, each peer stores a copy of the blockchain locally. Thus, a block being linked to the blockchain means that each peer stores the block in their local blockchains. The blockchain consensus ensures that all peers store the same copy of the blockchain.

<div align="center">

<img src="Blockchain_Process.jpg" alt="Description" width="700"/>

<p><em>Figure 1: Operation process of a blockchain system (nodes in the figure are blockchain peers).</em></p>

</div>

As shown in Figure 1, the simple operation procedure of a blockchain system in a block period (i.e., the interval to generate a block) is as follows:

1. Peers generate new transactions and broadcast them to all peers in the system.
   
2. One of the peers is selected as a block generator to package transactions as a block.
  
3. The new block is broadcast to all peers in the system.

4. Each peer verify the validity of the block.
   
5. If most peers accept the block, the block is appended to the blockchain. As such, transactions in the block are stored in the blockchain permanently. A malicious peer intending to modify a block in the blockchain will change all following blocks, which requires all peers to reverify these blocks; this is considered impossible in Bitcoin.

In this project, we will focus on how peers in a blockchain system communicate to exchange data (e.g., transactions and blocks). We can see from Figure 1 that a blockchain system is implemented based on the **peer-to-peer (P2P) network**, in which peers exchange data directly without any centralized entities. This project aims at simulating this blockchain P2P network, which includes the functionality of **peer discovery**, **sending message processing** and **receiving message processing**. Moreover, for exchanging transactions and blocks, a simplified **transaction and block generation** is simulated. Finally, **peer initialization** is necessary before running a peer, and a **dashboard** is used to observe the operation of the network. The functionalities to be realized are summarized in Figure 2.

<div align="center">

<img src="Functionalities.jpg" alt="Description" width="700"/>

<p><em>Figure 2: Functionalities to complete in this project.</em></p>

</div>

## 2. Functionality of the Blockchain P2P Network

<div align="center">

<img src="Functionality_Relationship.jpg" alt="Description" width="700"/>

<p><em>Figure 3: Relationship between different functionalities.</em></p>

</div>

Figure 3 shows the relationship between different functionalities. In the following, we introduce each functionalities in detail.

### Part 1: Peer Initialization

When a new peer join the blockchain network, it must

* configure its `IP address`, `port`, and `gossip fanout`, and
  
* decide whether to act as a `normal` or `malicious`, `lightweight` or `full`, `NATed` or `non-NATed` peer.

After that, the peer can 
  
* create a `TCP socket` to receive incoming messages.

**Tips:**

* `gossip fanout`: In blockchains, peers usually adopt the gossip protocol while broadcasting blocks and transactions. That is, each peer sends blocks or transactions to a random subset instead of all of its known peers. This can reduce redundant messages in the network. `gossip fanout` indicates the number of target peers while broadcasting blocks and transactions.
  
* `normal` or `malicious` peer: A normal peer always generates correct transactions and blocks. Instead, a malicious peer can generate incorrect transactions and blocks (e.g., with the wrong block ID).
  
* `lightweight` or `full` peer: In the introduction, we introduce that all peers verify the block and store a copy of the blockchain, which is called full peers. However, in practice, there are some resource-limited devices (e.g., mobile phones and laptops), which do not have enough computing and storage capacities to verify and store all blocks. To solve this issue, Ethereum allows peers to act as lighweight peers, which do not verify blocks adn store all blocks. Instead, lightweight peers store the header of blocks without transactions.
  
* `NATed` or `non-NATed` peer: This project considers network address translation (NAT). A NATed peer is generally located in a local network and cannot interact directly with peers outside the local network. Instead, non-NATed peers in the local network act as NAT routers or relaying peers between NATed peers and peers outside the local network. Typically, while forwarding external messages to a peer in a local network, a relaying peer must find the destination peer’s IP address in the local network based on the NAT translation table. Here, to reduce the complexity, we only simulate the logic of NAT and ignore the NAT translation table; that is, a NATed peer has only one IP address across the network.

### Part 2: Peer Discovery

After creating the TCP socket, the peer informs known peers of its existence in order to exchange data. To do so, the peer must acquire some peers' IP addresses and ports before joining the network. Moreover, the peer periodically check if the known peers are alive. The procedure of peer discovery is as follows:

* Say `hello` to its known peers while joining the network.
  
* When receiving `hello` message, check if the sender is known. If not, add the sender to the list of known peers.
  
* Periodically send `ping` messages to all known peers and wait for their replies, i.e., `pong` messages.
  
* When receiving `pong` messages, update the state of known peers. Moreover, calculate the time difference between sending `ping` messages and receiving `pong` messages, which is the transmission latency between peers. 
  
* Remove unresponsive peers if no `pong` messages are received before the timeout.

### Part 3: Block and Transaction Generation and Verification

After initializing the peer and find the known peers, the full peer starts generating and verifying transactions and blocks. In this project, each full peer periodically generate one transaction and broadcast it to other full peers for verification. A transaction is valid if the transaction ID is correct. These transactions are also stored in the peer's local transaction pool `tx_pool`. 

Since we only focus on transaction and block exchange in the blockchain P2P network, we simplify block generation here. Instead of selecting a block generator to generate a block, in each block period, each peer packages transactions in their `tx_pool` into a block independently and broadcasts it to other peers for verification. A block is valid if the `block ID` is correct. 

The procedure of transaction and block generation and verification is as follows:

* Synchronize the latest blockchain from known peers while joining the network in order to link new blocks to the latest blockchain.
  
* Start generating transactions.
  
* Broadcast the transactions to known peers for verification.
  
* Add the valid transactions to the local `tx_pool`.
  
* Package the transactions in the local `tx_pool` into a new block.
  
* Broadcast the block to known peers for verification.
  
* Add the valid block to the local blockchain.

**Tips:**
* When a peer sends a block to another, the sender usually sends an `INV` message with the block ID instead of the block itself. If the receiver finds that it has not yet received the block, the receiver will reply with a `GETBLOCK` message to request the block. This can reduce the network overhead.
  
* When receiving a `GETBLOCK` message, a peer replies with the block if the sender is a full peer; otherwise, a peer replies with the block's header because lightweight peers only store the header of blocks.

### Part 4: Sending Messages Processing

To simulate the process of sending messages (e.g., transactions and blocks), all sending messages must be put into an outbox queue and sent one by one. The procedure of sending messages is as follows:

* When sending a message, add the message to the outbox queue.
  
* Read a message from the queue based on their priorities.

* If the message destination is a non-NATed peer, send the message to the destination directly.
  
* If the message destination is a NATed peer, find the best relaying peer and send the message to the relaying peer.

### Part 4: Receiving Messages Processing

When receiving messages from other peers, the messages must be dispatched and processed based on the message type. The receiving messages processing is as follows:

* Check whether the message sender is banned. Drop the message if the sender is banned.
  
* Check whether the number of messages sent by the sender is within the limit. Drop the message if the sender sends messages too frequently. This is to prevent denial-of-service (DoS) attacks.
  
* Check the message type and process the messages accordingly:
  
  * msg.type=`TX`,
    * Check the validity of the transaction. If invalid, drop the transaction and record the sender's offence.
    * Check whether the transaction has been received. If yes, drop the transaction to prevent replay attacks.
    * Record the count of redundant transactions if they have been received.
    * Add the new transaction to the local `tx_pool` if it has not been received.
    * Broadcast the new transaction to known peers.
      
  * msg.type=`BLOCK`,
    * Check the validity of the block. If invalid, drop the block and record the sender's offence.
    * Check whether the block has been received. If yes, drop the block to prevent replay attacks.
    * Record the count of redundant blocks if they have been received.
    * Add the new block to the list of orphaned blocks if its previous block does not exist in the blockchain due to network delay.
    * Add the new block to the local blockchain if its prevent block exists in the blockchain.
    * Check whether the new block is the previous block of the orphaned blocks.
    * Broadcast the new block to known peers.
      
  * msg.type=`INV`,
    * Check whether the block ID in the INV message have been received.
    * Request missing blocks from the message sender.
      
  * msg.type=`GETBLOCK`,
    * Check whether the blocks requested are in the local blockchain. If not, request the blocks from known peers.
    * If the sender is a full peer, reply with the requested blocks.
    * If the sender is a lightweight peer, reply with the header of the requested blocks.
      
  * msg.type=`GET_BLOCK_HEADERS`
    * Reply with the header of blocks in the local blockchain.
      
  * msg.type=`BLOCK_HEADERS`
    * Check the validity of the list of block headers by checking whether the previous block of each block exists in the blockchain.
    * Request the missing block from known peers if the peer is a full peer.


### Part 5: Start Dashboard

Start a dashboard server to display the following message:

* `Localhost: port/peers`: display the set of known peers.
  
* `Localhost: port/status`: display the status of peers in the network.
  
* `Localhost: port/transactions`: display the transactions in the local pool.
  
* `Localhost: port/blocks`: display the blocks in the local blockchain.
  
* `Localhost: port/orphan`: display the orphaned blocks.
  
* `Localhost: port/latency`: display the transmission latency between peers.
  
* `Localhost: port/capacity`: display the sending capacity of the peers.
  
* `Localhost: port/redundancy`: display the number of redundant blocks and transactions received.
  
* `Localhost: port/scores`: display peers' scores in the network.


## 3. Functions to Complete

The operation logic of the project is given in the `Main` function of `node.py`. In the following, the functions to be completed in each part are explained as follows.

### Part 1: Peer Initialization (`socket_server.py`)

1. `start_socket_server` 

* Create a TCP socket and bind it to the peer’s IP address and port.
  
* Start listening on the socket for receiving incoming messages.

* When receiving messages, pass the messages to the function `dispatch_message` in `message_handler.py`.

### Part 2: Peer Discovery 

#### `peer_discovery.py`: This part is responsible for saying 'hello' to known peers when the peer joins the system.

1. `start_peer_discovery` 
   
* Define the JSON format of a `hello` message, which should include: `{message type, sender’s ID, IP address, port, flags, and message ID}`. A `sender’s ID` can be `peer_port`. The `flags` should indicate whether the peer is `NATed or non-NATed`, and `full or lightweight`. The `message ID` can be a random number.

* Send a `hello` message to all known peers and put the messages into the outbox queue.
  
2. `handle_hello_message`

* Read information in the received `hello` message.
     
* If the sender is unknown, add it to the list of known peers (`known_peer`) and record their flags (`peer_flags`).
     
* Update the set of reachable peers (`reachable_by`).

**Tips:** Each peer can only receive `hello` messages from reachable peers and never forward `hello` messages. If a peer receives `hello` messages from a NATed peer, it can act as the relaying peers of the NATed peer.

#### `peer_manager.py`: This part is responsible for checking the status and recording the performance of known peers.

1. `start_ping_loop`

* Define the JSON format of a `ping` message, which should include `{message typy, sender's ID, timestamp}`.

* Send a `ping` message to each known peer periodically.

2. `create_pong`

* Create the JSON format of a `pong` message, which should include `{message type, sender's ID, timestamp in the received ping message}`

3. `handle_pong`

* Read the information in the received `pong` message.

* Update the transmission latenty between the peer and the sender (`rtt_tracker`).

4. `start_peer_monitor`

* Check the latest time to receive `ping` or `pong` message from each peer in `last_ping_time`.

* If the latest time is earlier than the limit, mark the peer's status in `peer_status` as `UNREACHABLE` or otherwise `ALIVE`.

5. `update_peer_heartbeat`

* Update the `last_ping_time` of a peer when receiving its `ping` or `pong` message.

--------------------------------------------------

6. `record_offense`

* Record the offence times of a peer when malicious behaviors are detected.

* Add a peer to `blacklist` if its offence times exceed 3.


### Part 3: Block and Transaction Generation and Verification

#### `transaction.py`: This part processes all transaction-related functions.

1. `transaction_generation`

* Randomly choose a peer from `known_peers` and generate a transaction to transfer arbitrary amount of money to the peer.

* Add the transaction to local `tx_pool` using the function `add_transaction`.

* Broadcast the transaction to `known_peers` using the function `gossip_message` in `outbox.py`.

2. `add_transaction`

* Add a transaction to the local `tx_pool` if it is in the pool.

* Add the transaction ID to `tx_ids`.

3. `get_recent_transaction`

* Return all transactions in the local `tx_pool`.

5. `clear_pool`

* Remove all transactions in `tx_pool` and transaction IDs in `tx_ids`.

#### `block_handler.py`: This part processes all block-related functions.

6. `request_block_sync`

* Define the JSON format of a `GET_BLOCK_HEADERS`, which should include `{message type, sender's ID}`.

* Send a `GET_BLOCK_HEADERS` message to each known peer and put the messages in the outbox queue.

7. `block_generation`

* Create a new block periodically using the function `create_dummy_block`.

* Create an `INV` message for the new block using the function `create_inv`.

* Broadcast the `INV` message to known peers using the function `gossip` in `outbox.py`.

1. `request_block_sync` (`node.py`)
   
* Define the JSON format of a `GET_BLOCK_HEADERS` message, which should include `{message type, from_id}`. `from_id` is the `sender’s alias`.
    
* Send a `GET_BLOCK_HEADERS` message to all known peers and put the messages into the outbox queue.

2. `start_transaction_broadcast` (node.py)
   
* Generate the set of transactions with random `senders` and `receivers` (selected from known peers). The structure of a transaction is defined in `TransactionMessage` in `transaction_message.py`.
     
* Broadcast the transactions to known peers based on gossip and put the message into the outbox queue.

3. `start_block_generation` (node.py)
   
* Exploit the function `create_dummy_block` in `block_handler.py` to generate blocks periodically.
     
* Create an `INV` message for the new blocks.
     
* Send the `INV` message to known peers and put the messages into the outbox queue.
  
4. `create_dummy_block` (`block_handler.py`)
   
* Define the JSON format of a `block`, which should include `{type: Block, Block Generator’s Alias, Timestamp, Block Height, Block ID, ID of Block’s Parent, and Transactions}`. The `block ID` is the hash value of block structure except for the item of the block ID. A `block’s parent` is the last block in the blockchain, to which the new block will be linked. The `block height` of a block is the height of its parent block plus one. If the block generator is malicious, it can generate random block ID.
     
* Read the transactions in the local pool using the function `get_recent_transactions` and create a new block.
     
* Clear the local transaction pool and add the new block into the local blockchain defined as `receive_block`.

5. `add_transaction` (`tx_pool.py`)
   
* Add new transactions to the local pool `tx_pool`.

6. `get_recent_transactions` (`tx_pool.py`)
   
* Read the transactions in the local pool.

7. `clear_pool` (`tx_pool.py`)
   
* Remove transactions in the pool after packaging them into new blocks.

8. `create_inv` (`network/inv_message.py`)
   
* Create the JSON format of an `INV` message, which should include: `{message type, sender’s ID, blocks’ ID, and message ID}`.

### Part 3: Sending Messages

1. `enqueue_message` (`outbox.py`)

This function put all sending messages into an outbox queue. The procedure of the function is as follows:

* Check if the sender sends message to the receiver too frequently using the function `Is_rate_limited`. If yes, drop the message.
  
* Check if the receiver is banned using the function `Is_banned`.
  
* Classify the priority of the sending messages based on the message type using the function `Classify_priority`.
  
* Add the message to the queue if the length of the queue is within the limit `QUEUE_LIMIT`, or otherwise, drop the message.

2. `Is_rate_limited` (`outbox.py`)
   
* Check how many messages were sent from the peer to a target peer during the `TIME_WINDOW` that ends now.
  
* Check if the sending frequency exceeds the sending rate limit `RATE_LIMIT`.
  
* Record the current sending time into `peer_send_timestamps`.

3. `Is_banned` (`peer_manager.py`)
   
* Check if a peer is in the blacklist.

4. `record_offence` (`peer_manager.py`)
   
* Record the offence when detecting malicious behavior of a peer.
  
* Ban the peer using the function `ban_peer` if the number of offences exceeds the limit `OFFENCE_LIMIT`.

5. `ban_peer` (`peer_manager.py`)

* Add a peer to the blacklist.

6. `send_from_queue` (`outbox.py`)
   
* Read the message in the queue. Each time, read a target peer’s message with the highest priority. Then, move to the next target peer’s message. This can ensure the fairness of sending messages to different target peers.

* Check sending the message to the target peer directly or through a relaying node using the function `relay_or_direct_send`.

* Retry a message if it is sent unsuccessfully and drop the message if the number of retry exceed the limit `MAX_RETRIES`.

7. `classify_priority` (`outbox.py`)
   
*	Classify the priority of a message based on the message type.

8. `get_outbox_status` (`outbox.py`)
   
* Read the sending message in the queues.

9. `relay_or_direct_send` (`network/link_simulator.py`)

* Check if the target peer is NATed. If yes, use the function `get_relay_peer` to find the best relaying peer.
  
* Send the message to the target peer or relaying peer using the function `send_message`.

10. `get_relay_peer` (`network/link_simulator.py`)
    
* Read the latency between the sender and other peers in `rtt_tracker` in `peer_manager.py`.
  
* Find the set of relay candidates reachable from the target peer.
  
* Select the best relaying peers with the smallest latency.

11. `send_message` (`node.py`)

* Send the message to the target peer. Wrap the function `send_message` with the dynamic network condition in the function `apply_network_condition`.



















































